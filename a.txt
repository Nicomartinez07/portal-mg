Otra cosa que me olvide decirte que en el ordenes, tambien puede haber borradores porque un campo de la tabla es un booleano llamado draft

ahi te paso el schema con todo lo relacionado a ordenes  


// =============== ORDENES =================
model Order {
Â  idÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â IntÂ  Â  Â  Â  @id @default(autoincrement())
Â  orderNumberÂ  Â  Â  Â  Â  Â  Int @default(99999)
Â  typeÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â OrderType
Â  creationDateÂ  Â  Â  Â  Â  Â DateTime
  draft                  Boolean?
Â  customerIdÂ  Â  Â  Â  Â  Â  Â Int?
Â  customerÂ  Â  Â  Â  Â  Â  Â  Â Customer?Â  Â @relation(fields: [customerId], references: [id])
Â  vehicleVinÂ  Â  Â  Â  Â  Â  Â String
Â  vehicleÂ  Â  Â  Â  Â  Â  Â  Â  VehicleÂ  Â  @relation(fields: [vehicleVin], references: [vin])
Â  companyIdÂ  Â  Â  Â  Â  Â  Â  Int
Â  companyÂ  Â  Â  Â  Â  Â  Â  Â  CompanyÂ  Â  @relation(fields: [companyId], references: [id])
Â  userIdÂ  Â  Â  Â  Â  Â  Â  Â  Â Int?
Â  userÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â User?Â  Â  Â @relation(fields: [userId], references: [id])
Â  statusÂ  Â  Â  Â  Â  Â  Â  Â  Â OrderStatus?
  service                String? 
Â  internalStatusÂ  Â  Â  Â  Â InternalStatus?
Â  actualMileageÂ  Â  Â  Â  Â  Int
Â  diagnosisÂ  Â  Â  Â  Â  Â  Â  String?
Â  additionalObservations String?
  preAuthorizationNumber  String? 
Â  tasksÂ  Â  Â  Â  Â  Â  Â  Â  Â  OrderTask[]
Â  photosÂ  Â  Â  Â  Â  Â  Â  Â  Â OrderPhoto[]
Â  statusHistoryÂ  Â  Â  Â  Â  OrderStatusHistory[]
}

model OrderTask {
Â  idÂ  Â  Â  Â  Â  IntÂ  Â  Â  Â  Â  Â  @id @default(autoincrement())
Â  orderIdÂ  Â  Â Int
Â  orderÂ  Â  Â  Â OrderÂ  Â  Â  Â  Â  @relation(fields: [orderId], references: [id])
Â  description String
Â  hoursCountÂ  Int
Â  partsÂ  Â  Â  Â OrderTaskPart[]
}

model OrderTaskPart {
Â  idÂ  Â  Â  Â  Â  IntÂ  Â  Â  @id @default(autoincrement())
Â  orderTaskId Int
Â  partIdÂ  Â  Â  Int
Â  quantityÂ  Â  Int
Â  description String?
Â  orderTaskÂ  Â OrderTask @relation(fields: [orderTaskId], references: [id])
Â  partÂ  Â  Â  Â  PartÂ  Â  Â  @relation(fields: [partId], references: [id])
}

model OrderPhoto {
Â  idÂ  Â  Â  IntÂ  Â  @id @default(autoincrement())
Â  orderId Int
Â  orderÂ  Â OrderÂ  @relation(fields: [orderId], references: [id])
Â  typeÂ  Â  String // ej: "license_plate", "vin_plate", "odometer", "extra"
Â  urlÂ  Â  Â String
}

model OrderStatusHistory {
Â  idÂ  Â  Â  Â  IntÂ  Â  Â  Â  Â  @id @default(autoincrement())
Â  orderIdÂ  Â Int
Â  orderÂ  Â  Â OrderÂ  Â  Â  Â  @relation(fields: [orderId], references: [id])
Â  statusÂ  Â  OrderStatus? 
Â  changedAt DateTimeÂ  Â  Â @default(now())
  observation String?
}


A CONTINUACION TE MANDO EL ACTIONS DE INSERTAR UN SERVICIO

// src/app/ordenes/insert/servicio/actions.ts
"use server";

import { prisma } from "@/lib/prisma";
import { CreateServiceResult } from "@/app/types";
import { serviceSchema, draftServiceSchema } from '@/schemas/service';
import { z } from 'zod';

// Guardar servicio (completo o borrador)
export async function saveService(
  serviceData: any,
  companyId: number,
  userId?: number,
  isDraft: boolean = false,
  draftId?: number
): Promise<CreateServiceResult> {
  try {
    // 1. VALIDAR CON ZOD - schema diferente para borradores
    const validatedData = isDraft 
      ? draftServiceSchema.parse(serviceData)
      : serviceSchema.parse(serviceData);

    // 2. VALIDAR QUE EL VEHÃCULO EXISTA
    const vehicle = await prisma.vehicle.findUnique({
      where: { vin: validatedData.vin },
    });

    if (!vehicle) {
      return { success: false, message: "VehÃ­culo no encontrado" };
    }

    // ğŸ”’ TRANSACCIÃ“N
    const service = await prisma.$transaction(async (tx) => {
      if (draftId) {
        console.log(`ğŸ”„ Actualizando borrador de servicio ID: ${draftId}, isDraft: ${isDraft}`);
        
        // Actualizar orden existente
        const updateData: any = {
          draft: isDraft,
          status: isDraft ? "BORRADOR" : "COMPLETADO",
          actualMileage: validatedData.actualMileage || 0,
          additionalObservations: validatedData.additionalObservations || "",
          service: validatedData.service || null,
          type: "SERVICIO",
        };
        if (validatedData.vin) {
          updateData.vehicle = { connect: { vin: validatedData.vin } };
        }

        const updatedOrder = await tx.order.update({
          where: { id: draftId },
          data: updateData,
        });

        // Agregar historial si se convierte a orden completa
        if (!isDraft) {
          await tx.orderStatusHistory.create({
            data: {
              orderId: draftId,
              status: "PENDIENTE",
              changedAt: new Date(),
            },
          });
        }

        return tx.order.findUnique({
          where: { id: draftId },
          include: {
            customer: true,
            vehicle: true,
          },
        });

      } else {
        // ğŸ‘‡ CREAR NUEVO SERVICIO
        console.log("ğŸ†• Creando nuevo servicio/borrador");

        // Determinar nÃºmero de orden (solo para servicios completos)
        let orderNumber = 99999;
        if (!isDraft) {
          const lastOrder = await tx.order.findFirst({
            where: { draft: false },
            orderBy: { orderNumber: "desc" },
          });
          orderNumber = lastOrder ? lastOrder.orderNumber + 1 : 100000;
        }
        // Crear nueva orden de servicio
        const newOrder = await tx.order.create({
          data: {
            orderNumber,
            type: "SERVICIO",
            creationDate: new Date(),
            draft: isDraft,
            vehicle: { connect: { vin: validatedData.vin } },
            company: { connect: { id: companyId } },
            user: userId ? { connect: { id: userId } } : undefined,
            status: isDraft ? "BORRADOR" : "COMPLETADO",
            internalStatus: null,
            actualMileage: validatedData.actualMileage || 0,
            additionalObservations: validatedData.additionalObservations || "",
            statusHistory: isDraft
              ? {
                  create: [{
                    status: "BORRADOR",
                    changedAt: new Date(),
                  }],
                }
              : undefined,
            service: validatedData.service || null,
          },
        });

        return tx.order.findUnique({
          where: { id: newOrder.id },
          include: {
            customer: true,
            vehicle: true,
          },
        });
      }
    });

    // Mensaje de Ã©xito
    let message = draftId
      ? (isDraft 
          ? "âœ… Borrador de servicio actualizado correctamente" 
          : "âœ… Borrador convertido a servicio exitosamente")
      : (isDraft
          ? "âœ… Borrador de servicio guardado correctamente"
          : "âœ… Servicio creado exitosamente");

    return { success: true, service, message };

  } catch (error) {
    // Manejar errores de Zod
    if (error instanceof z.ZodError) {
      const errors: Record<string, string> = {};
      error.issues.forEach(err => {
        if (err.path && err.path[0]) {
          const fieldName = err.path.join('.');
          errors[fieldName] = err.message;
        }
      });
      return {
        success: false,
        errors,
        message: "âŒ Errores de validaciÃ³n en el formulario"
      };
    }

    console.error("Error en saveService:", error);
    return {
      success: false,
      message: error instanceof Error ? error.message : "âŒ Error interno del servidor",
    };
  }
}

